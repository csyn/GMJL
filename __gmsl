# ----------------------------------------------------------------------------
#
# GNU Make Standard Library (GMSL)
#
# A library of functions to be used with GNU Make's $(call) that
# provides functionality not available in standard GNU Make.
#
# Copyright (c) 2005-2014 John Graham-Cumming
#
# This file is part of GMSL
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
#
# Redistributions of source code must retain the above copyright
# notice, this list of conditions and the following disclaimer.
#
# Redistributions in binary form must reproduce the above copyright
# notice, this list of conditions and the following disclaimer in the
# documentation and/or other materials provided with the distribution.
#
# Neither the name of the John Graham-Cumming nor the names of its
# contributors may be used to endorse or promote products derived from
# this software without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
# POSSIBILITY OF SUCH DAMAGE.
#
# ----------------------------------------------------------------------------
#
# Modified by Julian Ingram, 2016
# - Updated the algorithm for the arithmetic functions to allow larger numbers
#
# This is the GNU Make Standard Library version number as a list with
# three items: major, minor, revision

gmsl_version := 1 1 7 m

__gmsl_name := GNU Make Standard Library

# Used to output warnings and error from the library, it's possible to
# disable any warnings or errors by overriding these definitions
# manually or by setting GMSL_NO_WARNINGS or GMSL_NO_ERRORS

ifdef GMSL_NO_WARNINGS
__gmsl_warning :=
else
__gmsl_warning = $(if $1,$(warning $(__gmsl_name): $1))
endif

ifdef GMSL_NO_ERRORS
__gmsl_error :=
else
 __gmsl_error = $(if $1,$(error $(__gmsl_name): $1))
endif

# If GMSL_TRACE is enabled then calls to the library functions are
# traced to stdout using warning messages with their arguments

ifdef GMSL_TRACE
__gmsl_tr1 = $(warning $0('$1'))
__gmsl_tr2 = $(warning $0('$1','$2'))
__gmsl_tr3 = $(warning $0('$1','$2','$3'))
else
__gmsl_tr1 :=
__gmsl_tr2 :=
__gmsl_tr3 :=
endif

# See if spaces are valid in variable names (this was the case until
# GNU Make 3.82)
ifeq ($(MAKE_VERSION),3.82)
__gmsl_spaced_vars := $(false)
else
__gmsl_spaced_vars := $(true)
endif

# Figure out whether we have $(eval) or not (GNU Make 3.80 and above)
# if we do not then output a warning message, if we do then some
# functions will be enabled.

__gmsl_have_eval := $(false)
__gmsl_ignore := $(eval __gmsl_have_eval := $(true))

# If this is being run with Electric Cloud's emake then warn that
# their $(eval) support is incomplete in 1.x, 2.x, 3.x, 4.x and 5.0,
# 5.1, 5.2 and 5.3

ifdef ECLOUD_BUILD_ID
__gmsl_emake_major := $(word 1,$(subst ., ,$(EMAKE_VERSION)))
__gmsl_emake_minor := $(word 2,$(subst ., ,$(EMAKE_VERSION)))
ifneq ("$(findstring $(__gmsl_emake_major),1 2 3 4)$(findstring $(__gmsl_emake_major)$(__gmsl_emake_minor),50 51 52 53)","")
$(warning You are using a version of Electric Cloud's emake which has incomplete $$(eval) support)
__gmsl_have_eval := $(false)
endif
endif

# See if we have $(lastword) (GNU Make 3.81 and above)

__gmsl_have_lastword := $(lastword $(false) $(true))

# See if we have native or and and (GNU Make 3.81 and above)

__gmsl_have_or := $(if $(filter-out undefined,  \
    $(origin or)),$(call or,$(true),$(false)))
__gmsl_have_and := $(if $(filter-out undefined, \
    $(origin and)),$(call and,$(true),$(true)))

ifneq ($(__gmsl_have_eval),$(true))
$(call __gmsl_warning,Your make version $(MAKE_VERSION) does not support $$$$(eval): some functions disabled)
endif

__gmsl_dollar := $$
__gmsl_hash := \#
__gmsl_digits := 0 1 2 3 4 5 6 7 8 9
__gmsl_inc_lut := 2 3 4 5 6 7 8 9 0
__gmsl_hex_digits := 0 1 2 3 4 5 6 7 8 9 a b c d e f

# ----------------------------------------------------------------------------
# ----------------------------------------------------------------------------
# Function:  gmsl_compatible
# Arguments: List containing the desired library version number (maj min rev)
# Returns:   $(true) if this version of the library is compatible
#            with the requested version number, otherwise $(false)
# ----------------------------------------------------------------------------
gmsl_compatible = $(strip                                                 \
    $(if $(call gt,$(word 1,$1),$(word 1,$(gmsl_version))),               \
        $(false),                                                         \
        $(if $(call lt,$(word 1,$1),$(word 1,$(gmsl_version))),           \
            $(true),                                                      \
            $(if $(call gt,$(word 2,$1),$(word 2,$(gmsl_version))),       \
                $(false),                                                 \
                $(if $(call lt,$(word 2,$1),$(word 2,$(gmsl_version))),   \
                    $(true),                                              \
                    $(call lte,$(word 3,$1),$(word 3,$(gmsl_version))))))))

# ###########################################################################
# LOGICAL OPERATORS
# ###########################################################################

# not is defined in gmsl

# ----------------------------------------------------------------------------
# Function:  and
# Arguments: Two boolean values
# Returns:   Returns $(true) if both of the booleans are true
# ----------------------------------------------------------------------------
ifneq ($(__gmsl_have_and),$(true))
and = $(__gmsl_tr2)$(if $1,$(if $2,$(true),$(false)),$(false))
endif

# ----------------------------------------------------------------------------
# Function:  or
# Arguments: Two boolean values
# Returns:   Returns $(true) if either of the booleans is true
# ----------------------------------------------------------------------------
ifneq ($(__gmsl_have_or),$(true))
or = $(__gmsl_tr2)$(if $1$2,$(true),$(false))
endif

# ----------------------------------------------------------------------------
# Function:  xor
# Arguments: Two boolean values
# Returns:   Returns $(true) if exactly one of the booleans is true
# ----------------------------------------------------------------------------
xor = $(__gmsl_tr2)$(if $1,$(if $2,$(false),$(true)),$(if $2,$(true),$(false)))

# ----------------------------------------------------------------------------
# Function:  nand
# Arguments: Two boolean values
# Returns:   Returns value of 'not and'
# ----------------------------------------------------------------------------
nand = $(__gmsl_tr2)$(if $1,$(if $2,$(false),$(true)),$(true))

# ----------------------------------------------------------------------------
# Function:  nor
# Arguments: Two boolean values
# Returns:   Returns value of 'not or'
# ----------------------------------------------------------------------------
nor = $(__gmsl_tr2)$(if $1$2,$(false),$(true))

# ----------------------------------------------------------------------------
# Function:  xnor
# Arguments: Two boolean values
# Returns:   Returns value of 'not xor'
# ----------------------------------------------------------------------------
xnor =$(__gmsl_tr2)$(if $1,$(if $2,$(true),$(false)),$(if $2,$(false),$(true)))

# ###########################################################################
# LIST MANIPULATION FUNCTIONS
# ###########################################################################

# ----------------------------------------------------------------------------
# Function:  first (same as LISP's car, or head)
# Arguments: 1: A list
# Returns:   Returns the first element of a list
# ----------------------------------------------------------------------------
first = $(__gmsl_tr1)$(firstword $1)

# ----------------------------------------------------------------------------
# Function:  last
# Arguments: 1: A list
# Returns:   Returns the last element of a list
# ----------------------------------------------------------------------------
ifeq ($(__gmsl_have_lastword),$(true))
last = $(__gmsl_tr1)$(lastword $1)
else
last = $(__gmsl_tr1)$(if $1,$(word $(words $1),$1))
endif

# ----------------------------------------------------------------------------
# Function:  rest (same as LISP's cdr, or tail)
# Arguments: 1: A list
# Returns:   Returns the list with the first element removed
# ----------------------------------------------------------------------------
rest = $(__gmsl_tr1)$(wordlist 2,$(words $1),$1)

# ----------------------------------------------------------------------------
# Function:  chop
# Arguments: 1: A list
# Returns:   Returns the list with the last element removed
# ----------------------------------------------------------------------------
chop = $(__gmsl_tr1)$(wordlist 2,$(words $1),x $1)

# ----------------------------------------------------------------------------
# Function:  map
# Arguments: 1: Name of function to $(call) for each element of list
#            2: List to iterate over calling the function in 1
# Returns:   The list after calling the function on each element
# ----------------------------------------------------------------------------
map = $(__gmsl_tr2)$(strip $(foreach a,$2,$(call $1,$a)))

# ----------------------------------------------------------------------------
# Function:  pairmap
# Arguments: 1: Name of function to $(call) for each pair of elements
#            2: List to iterate over calling the function in 1
#            3: Second list to iterate over calling the function in 1
# Returns:   The list after calling the function on each pair of elements
# ----------------------------------------------------------------------------
pairmap = $(strip $(__gmsl_tr3)\
          $(if $2$3,$(call $1,$(call first,$2),$(call first,$3))     \
                        $(call pairmap,$1,$(call rest,$2),$(call rest,$3))))

# ----------------------------------------------------------------------------
# Function:  leq
# Arguments: 1: A list to compare against...
#            2: ...this list
# Returns:   Returns $(true) if the two lists are identical
# ----------------------------------------------------------------------------
leq = $(__gmsl_tr2)$(strip $(if $(call seq,$(words $1),$(words $2)),     \
          $(call __gmsl_list_equal,$1,$2),$(false)))

__gmsl_list_equal = $(if $(strip $1),                                       \
                        $(if $(call seq,$(call first,$1),$(call first,$2)), \
                            $(call __gmsl_list_equal,                       \
                                $(call rest,$1),                            \
                                $(call rest,$2)),                           \
                            $(false)),                                      \
                     $(true))

# ----------------------------------------------------------------------------
# Function:  lne
# Arguments: 1: A list to compare against...
#            2: ...this list
# Returns:   Returns $(true) if the two lists are different
# ----------------------------------------------------------------------------
lne = $(__gmsl_tr2)$(call not,$(call leq,$1,$2))

# ----------------------------------------------------------------------------
# Function:  reverse
# Arguments: 1: A list to reverse
# Returns:   The list with its elements in reverse order
# ----------------------------------------------------------------------------
reverse =$(__gmsl_tr1)$(strip $(if $1,$(call reverse,$(call rest,$1)) \
                        $(call first,$1)))

# ----------------------------------------------------------------------------
# Function:  uniq
# Arguments: 1: A list from which to remove repeated elements
# Returns:   The list with duplicate elements removed without reordering
# ----------------------------------------------------------------------------
uniq = $(strip $(__gmsl_tr1) $(if $1,$(firstword $1) \
                               $(call uniq,$(filter-out $(firstword $1),$1))))

# ----------------------------------------------------------------------------
# Function:  length
# Arguments: 1: A list
# Returns:   The number of elements in the list
# ----------------------------------------------------------------------------
length = $(__gmsl_tr1)$(words $1)

# ###########################################################################
# STRING MANIPULATION FUNCTIONS
# ###########################################################################

# Helper function that translates any GNU Make 'true' value (i.e. a
# non-empty string) to our $(true)

__gmsl_make_bool = $(if $(strip $1),$(true),$(false))

# ----------------------------------------------------------------------------
# Function:  seq
# Arguments: 1: A string to compare against...
#            2: ...this string
# Returns:   Returns $(true) if the two strings are identical
# ----------------------------------------------------------------------------
seq = $(__gmsl_tr2)$(if $(subst x$1,,x$2)$(subst x$2,,x$1),$(false),$(true))

# ----------------------------------------------------------------------------
# Function:  sne
# Arguments: 1: A string to compare against...
#            2: ...this string
# Returns:   Returns $(true) if the two strings are not the same
# ----------------------------------------------------------------------------
sne = $(__gmsl_tr2)$(call not,$(call seq,$1,$2))

# ----------------------------------------------------------------------------
# Function:  split
# Arguments: 1: The character to split on
#            2: A string to split
# Returns:   Splits a string into a list separated by spaces at the split
#            character in the first argument
# ----------------------------------------------------------------------------
split = $(__gmsl_tr2)$(strip $(subst $1, ,$2))

# ----------------------------------------------------------------------------
# Function:  merge
# Arguments: 1: The character to put between fields
#            2: A list to merge into a string
# Returns:   Merges a list into a single string, list elements are separated
#            by the character in the first argument
# ----------------------------------------------------------------------------
merge = $(__gmsl_tr2)$(strip $(if $2,                                     \
            $(if $(call seq,1,$(words $2)),                               \
                $2,$(call first,$2)$1$(call merge,$1,$(call rest,$2)))))

ifdef __gmsl_have_eval
# ----------------------------------------------------------------------------
# Function:  tr
# Arguments: 1: The list of characters to translate from
#            2: The list of characters to translate to
#            3: The text to translate
# Returns:   Returns the text after translating characters
# ----------------------------------------------------------------------------
tr = $(strip $(__gmsl_tr3)$(call assert_no_dollar,$0,$1$2$3)              \
     $(eval __gmsl_t := $3)                                               \
     $(foreach c,                                                         \
         $(join $(addsuffix :,$1),$2),                                    \
         $(eval __gmsl_t :=                                               \
             $(subst $(word 1,$(subst :, ,$c)),$(word 2,$(subst :, ,$c)), \
                 $(__gmsl_t))))$(__gmsl_t))

# Common character classes for use with the tr function.  Each of
# these is actually a variable declaration and must be wrapped with
# $() or ${} to be used.

[A-Z] := A B C D E F G H I J K L M N O P Q R S T U V W X Y Z #
[a-z] := a b c d e f g h i j k l m n o p q r s t u v w x y z #
[0-9] := 0 1 2 3 4 5 6 7 8 9 #
[A-F] := A B C D E F #

# ----------------------------------------------------------------------------
# Function:  uc
# Arguments: 1: Text to upper case
# Returns:   Returns the text in upper case
# ----------------------------------------------------------------------------
uc = $(__gmsl_tr1)$(call assert_no_dollar,$0,$1)$(call tr,$([a-z]),$([A-Z]),$1)

# ----------------------------------------------------------------------------
# Function:  lc
# Arguments: 1: Text to lower case
# Returns:   Returns the text in lower case
# ----------------------------------------------------------------------------
lc = $(__gmsl_tr1)$(call assert_no_dollar,$0,$1)$(call tr,$([A-Z]),$([a-z]),$1)

# ----------------------------------------------------------------------------
# Function:  strlen
# Arguments: 1: A string
# Returns:   Returns the length of the string
# ----------------------------------------------------------------------------

# This results in __gmsl_tab containing a tab

__gmsl_tab :=	#

__gmsl_characters := A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
__gmsl_characters += a b c d e f g h i j k l m n o p q r s t u v w x y z
__gmsl_characters += 0 1 2 3 4 5 6 7 8 9
__gmsl_characters += ` ~ ! @ \# $$ % ^ & * ( ) - _ = +
__gmsl_characters += { } [ ] \ : ; ' " < > , . / ? |

# This results in __gmsl_space containing just a space

__gmsl_space :=
__gmsl_space +=

strlen = $(__gmsl_tr1)$(call assert_no_dollar,$0,$1)$(strip $(eval __temp := $(subst $(__gmsl_space),x,$1))$(foreach a,$(__gmsl_characters),$(eval __temp := $$(subst $$a,x,$(__temp))))$(eval __temp := $(subst x,x ,$(__temp)))$(words $(__temp)))

# This results in __gmsl_newline containing just a newline

define __gmsl_newline


endef

# ----------------------------------------------------------------------------
# Function:  substr
# Arguments: 1: A string
#            2: Start position (first character is 1)
#            3: End position (inclusive)
# Returns:   A substring
# Note:      The string in $1 must not contain a �
# ----------------------------------------------------------------------------

substr = $(if $2,$(__gmsl_tr3)$(call assert_no_dollar,$0,$1$2$3)$(strip $(eval __temp := $$(subst $$(__gmsl_space),� ,$$1))$(foreach a,$(__gmsl_characters),$(eval __temp := $$(subst $$a,$$a$$(__gmsl_space),$(__temp))))$(eval __temp := $(wordlist $2,$3,$(__temp))))$(subst �,$(__gmsl_space),$(subst $(__gmsl_space),,$(__temp))))

endif # __gmsl_have_eval

# ###########################################################################
# SET MANIPULATION FUNCTIONS
# ###########################################################################

# Sets are represented by sorted, deduplicated lists.  To create a set
# from a list use set_create, or start with the empty_set and
# set_insert individual elements

# This is the empty set
empty_set :=

# ----------------------------------------------------------------------------
# Function:  set_create
# Arguments: 1: A list of set elements
# Returns:   Returns the newly created set
# ----------------------------------------------------------------------------
set_create = $(__gmsl_tr1)$(sort $1)

# ----------------------------------------------------------------------------
# Function:  set_insert
# Arguments: 1: A single element to add to a set
#            2: A set
# Returns:   Returns the set with the element added
# ----------------------------------------------------------------------------
set_insert = $(__gmsl_tr2)$(sort $1 $2)

# ----------------------------------------------------------------------------
# Function:  set_remove
# Arguments: 1: A single element to remove from a set
#            2: A set
# Returns:   Returns the set with the element removed
# ----------------------------------------------------------------------------
set_remove = $(__gmsl_tr2)$(filter-out $1,$2)

# ----------------------------------------------------------------------------
# Function:  set_is_member, set_is_not_member
# Arguments: 1: A single element
#            2: A set
# Returns:   (set_is_member) Returns $(true) if the element is in the set
#            (set_is_not_member) Returns $(false) if the element is in the set
# ----------------------------------------------------------------------------
set_is_member = $(__gmsl_tr2)$(if $(filter $1,$2),$(true),$(false))
set_is_not_member = $(__gmsl_tr2)$(if $(filter $1,$2),$(false),$(true))

# ----------------------------------------------------------------------------
# Function:  set_union
# Arguments: 1: A set
#            2: Another set
# Returns:   Returns the union of the two sets
# ----------------------------------------------------------------------------
set_union = $(__gmsl_tr2)$(sort $1 $2)

# ----------------------------------------------------------------------------
# Function:  set_intersection
# Arguments: 1: A set
#            2: Another set
# Returns:   Returns the intersection of the two sets
# ----------------------------------------------------------------------------
set_intersection = $(__gmsl_tr2)$(filter $1,$2)

# ----------------------------------------------------------------------------
# Function:  set_is_subset
# Arguments: 1: A set
#            2: Another set
# Returns:   Returns $(true) if the first set is a subset of the second
# ----------------------------------------------------------------------------
set_is_subset = $(__gmsl_tr2)$(call set_equal,$(call set_intersection,$1,$2),$1)

# ----------------------------------------------------------------------------
# Function:  set_equal
# Arguments: 1: A set
#            2: Another set
# Returns:   Returns $(true) if the two sets are identical
# ----------------------------------------------------------------------------
set_equal = $(__gmsl_tr2)$(call seq,$1,$2)

# ###########################################################################
# ARITHMETIC LIBRARY
# ###########################################################################

# ----------------------------------------------------------------------------
# Function:  arith_split
# Arguments: 1: An unsigned integer in human readable decimal form
# Returns:   A arith_split up list of decimal digits (list form)
# ----------------------------------------------------------------------------
arith_split = $(__gmsl_tr1)$(strip $(if $1,$(foreach d,$(__gmsl_digits),$(if $(1:$(d)%=),,$(d) $(call arith_split,$(1:$(d)%=%))))))

# ----------------------------------------------------------------------------
# Function:  arith_concat
# Arguments: 1: A number in list form
# Returns:   The integer for human consumption that is represented by
#            the list
# ----------------------------------------------------------------------------
arith_concat = $(__gmsl_tr1)$(subst $(__gmsl_space),,$1)

# ----------------------------------------------------------------------------
# Function:  rl_encode
# Arguments: 1: An unsigned integer in human readable decimal form
# Returns:   A reversed split up list of decimal digits with no leading zeros
#            (reversed list form)
# ----------------------------------------------------------------------------
rl_encode = $(__gmsl_tr1)$(call rl_slzs,$(call reverse,$(call arith_split,$1)))

# ----------------------------------------------------------------------------
# Function:  rl_decode
# Arguments: 1: An unsigned integer - in reversed list form
# Returns:   An unsigned integer in human-readable decimal form
# ----------------------------------------------------------------------------
rl_decode = $(__gmsl_tr1)$(call arith_concat,$(call reverse,$1))

# ----------------------------------------------------------------------------
# Function:  rl_wrap
# Arguments: 1: A function to call, accepting 1 argument in reversed list form
#            2: The argument to the function in human readable decimal form
# Returns:   Whatever the function returns
# ----------------------------------------------------------------------------
rl_wrap = $(__gmsl_tr2)$(call rl_decode,$(call $1,$(call rl_encode,$2)))

# ----------------------------------------------------------------------------
# Function:  rl_wrap2
# Arguments: 1: A function to call, accepting 2 arguments in reversed list form
#            2: The 1st argument to the function in human readable decimal form
#            2: The 2nd argument to the function in human readable decimal form
# Returns:   Whatever the function returns
# ----------------------------------------------------------------------------
rl_wrap2 = $(__gmsl_tr3)$(call rl_decode,$(call $1,$(call rl_encode,$2),$(call rl_encode,$3)))

# ----------------------------------------------------------------------------
# Function:  l_encode
# Arguments: 1: An unsigned integer in human readable decimal form
# Returns:   A split up list of decimal digits with no leading zeros (list form)
# ----------------------------------------------------------------------------
l_encode = $(__gmsl_tr1)$(call l_slzs,$(call arith_split,$1))

# ----------------------------------------------------------------------------
# Function:  l_wrap2
# Arguments: 1: A function to call, accepting 2 arguments in list form
#            2: The 1st argument to the function in human readable decimal form
#            2: The 2nd argument to the function in human readable decimal form
# Returns:   Whatever the function returns
# ----------------------------------------------------------------------------
l_wrap2 = $(__gmsl_tr3)$(call arith_concat,$(call $1,$(call l_encode,$2),$(call l_encode,$3)))

# ----------------------------------------------------------------------------
# Function:  rl_slz
# Arguments: 1: An unsigned integer in reversed list form
# Returns:   The argument, but less one leading zero, if one exists and the
#            total value is not 0 otherwise, returns the argument
# ----------------------------------------------------------------------------
rl_slz2 = $(if $(call nlz_eq,$(lastword $1),0),$(if $(call nlz_eq,$2,1),0,$(wordlist 1,$(call us_dec,$2),$1)),$1)
rl_slz = $(__gmsl_tr1)$(call rl_slz2,$1,$(words $1))

# ----------------------------------------------------------------------------
# Function:  rl_slzs
# Arguments: 1: An unsigned integer in reversed list form
# Returns:   The argument, but less all leading zeros. If the total value is 0,
#            returns 0
# ----------------------------------------------------------------------------
rl_slzs2 = $(if $(call nlz_eq,$(lastword $1),0),$(if $(call nlz_eq,$2,1),0,$(call rl_slzs,$(wordlist 1,$(call us_dec,$2),$1))),$1)
rl_slzs = $(__gmsl_tr1)$(call rl_slzs2,$1,$(words $1))

# ----------------------------------------------------------------------------
# Function:  l_slzs
# Arguments: 1: An unsigned integer in list form
# Returns:   The argument, but less all leading zeros. If the total value is 0,
#            returns 0
# ----------------------------------------------------------------------------
l_slzs2 = $(if $(call nlz_eq,$(firstword $1),0),$(if $(call nlz_eq,$2,1),0,$(call l_slzs,$(wordlist 2,$(words $1),$1))),$1)
l_slzs = $(__gmsl_tr1)$(call l_slzs2,$1,$(words $1))

# ----------------------------------------------------------------------------
# Function:  nlz_eq
# Arguments: 1: An unsigned integer in human readable decimal form with no
#            leading zeros
#            2: An unsigned integer in human readable decimal form with no
#            leading zeros
# Returns:   A non empty string if the 2 arguments are equal, otherwise an empty
#            string
# ----------------------------------------------------------------------------
nlz_eq = $(__gmsl_tr2)$(call __gmsl_make_bool,$(filter $1,$2))

# ----------------------------------------------------------------------------
# Function:  digit_lt
# Arguments: 1: A single decimal digit
#            2: A single decimal digit
# Returns:   A non empty string if argument 1 is less than argument 2,
#            otherwise an empty string
# ----------------------------------------------------------------------------
digit_lt = $(__gmsl_tr2)$(if $(call nlz_eq,$1,$2),,$(if $(call nlz_eq,$1,0),1,$(call digit_lt,$(word $1,$(__gmsl_digits)),$2)))

# ----------------------------------------------------------------------------
# Function:  digit_inc
# Arguments: 1: A single decimal digit
# Returns:   The argument + 1 or if the argument is 9, 0
# ----------------------------------------------------------------------------
digit_inc = $(__gmsl_tr1)$(if $(call nlz_eq,$1,0),1,$(word $1,$(__gmsl_inc_lut)))

# ----------------------------------------------------------------------------
# Function:  digit_dec
# Arguments: 1: A single decimal digit
# Returns:   The argument - 1 or if the argument is 0, 9
# ----------------------------------------------------------------------------
digit_dec = $(__gmsl_tr1)$(if $(call nlz_eq,$1,0),9,$(word $1,$(__gmsl_digits)))

# ----------------------------------------------------------------------------
# Function:  digit_add
# Arguments: 1: A single decimal digit
#            2: A single decimal digit
# Returns:   The sum of the 2 arguments mod 10
# ----------------------------------------------------------------------------
digit_add = $(__gmsl_tr2)$(if $(call nlz_eq,$2,0),$1,$(call digit_add,$(call digit_inc,$1),$(call digit_dec,$2)))

# ----------------------------------------------------------------------------
# Function:  digit_sub
# Arguments: 1: A single decimal digit
#            2: A single decimal digit
# Returns:   Argument 2 subtracted from argument 1, wrapping to 9
# ----------------------------------------------------------------------------
digit_sub = $(__gmsl_tr2)$(if $(call nlz_eq,$2,0),$1,$(call digit_sub,$(call digit_dec,$1),$(call digit_dec,$2)))

# ----------------------------------------------------------------------------
# Function:  l_lt
# Arguments: 1: An unsigned integer in list form
#            2: An unsigned integer in list form
# Returns:   A non empty string if argument 1 is less than argument 2,
#            otherwise an empty string
# ----------------------------------------------------------------------------
l_lt4 = $(if $(call digit_lt,$3,$4),$(true),$(if $(call nlz_eq,$3,$4),$(if $1,$(call l_lt,$1,$2),$(false)),$(false)))
l_lt3 = $(call l_lt4,$(wordlist 2,$3,$1),$(wordlist 2,$3,$2),$(firstword $1),$(firstword $2))
l_lt2 = $(if $(call nlz_eq,$3,$4),$(call l_lt3,$1,$2,$3),$(if $(call us_lt,$3,$4),$(true),$(false)))
l_lt = $(__gmsl_tr2)$(call l_lt2,$1,$2,$(words $1),$(words $2))

# ----------------------------------------------------------------------------
# Function:  rl_lt
# Arguments: 1: An unsigned integer in reversed list form
#            2: An unsigned integer in reversed list form
# Returns:   A non empty string if argument 1 is less than argument 2,
#            otherwise an empty string
# ----------------------------------------------------------------------------
rl_lt = $(__gmsl_tr2)$(call reverse,$(call l_lt,$(call reverse,$1),$(call reverse,$2)))

# ----------------------------------------------------------------------------
# Function:  rl_eq
# Arguments: 1: An unsigned integer in reversed list form
#            2: An unsigned integer in reversed list form
# Returns:   A non empty string if argument 1 equal to argument 2, otherwise an
#            empty string
# ----------------------------------------------------------------------------
rl_eq2 = $(if $(call nlz_eq,$(word 1,$1),$(word 1,$2)),$(if $(call nlz_eq,$(words $1),1),$(true),$(call rl_eq2,$(wordlist 2,$(words $1),$1),$(wordlist 2,$(words $2),$2))),$(false))
rl_eq = $(__gmsl_tr2)$(if $(call nlz_eq,$(words $1),$(words $2)),$(call rl_eq2,$1,$2),$(flase))

# ----------------------------------------------------------------------------
# Function:  rl_inc
# Arguments: 1: An unsigned integer in reversed list form
# Returns:   The argument + 1
# ----------------------------------------------------------------------------
rl_inc2 = $(if $(call nlz_eq,$2,0),1 $3,$(if $(call nlz_eq,$2,9),0 $(if $3,$(call rl_inc,$3),1),$(word $2,$(__gmsl_inc_lut)) $3))
rl_inc = $(__gmsl_tr1)$(call rl_inc2,$1,$(firstword $1),$(wordlist 2,$(words $1),$1))

# ----------------------------------------------------------------------------
# Function:  rl_dec
# Arguments: 1: An unsigned integer in reversed list form
# Returns:   The argument - 1, undefined if the argument is 0
# ----------------------------------------------------------------------------
rl_dec3 = $(if $(call nlz_eq,$2,0),9 $(call rl_dec2,$3),$(word $2,$(__gmsl_digits)) $3)
rl_dec2 = $(call rl_dec3,$1,$(firstword $1),$(wordlist 2,$(words $1),$1))
rl_dec = $(__gmsl_tr1)$(call rl_slz,$(call rl_dec2,$1))

rl_asx = $(call $1,$2,$3,$(firstword $2),$(firstword $3),$(wordlist 2,$(words $2),$2),$(wordlist 2,$(words $3),$3))

# ----------------------------------------------------------------------------
# Function:  rl_plus
# Arguments: 1: An unsigned integer in reversed list form
#            2: An unsigned integer in reversed list form
# Returns:   The sum of the 2 arguments
# ----------------------------------------------------------------------------
rl_plusc4 = $(if $1,$(if $2,$(call rl_asx,rl_plusc2,$1,$2),$(call rl_inc,$1)),$(if $2,$(call rl_inc,$2),1))
rl_plus4 = $(if $1,$(if $2,$(call rl_plus,$1,$2),$1),$2)
rl_plusc3 = $7 $(if $(call nlz_eq,$3,9)$(call digit_lt,$7,$4),$(call rl_plusc4,$5,$6),$(call rl_plus4,$5,$6))
rl_plus3 = $7 $(if $(call digit_lt,$7,$4),$(call rl_plusc4,$5,$6),$(call rl_plus4,$5,$6))
rl_plusc2 = $(call rl_plusc3,$1,$2,$3,$4,$5,$6,$(call digit_add,$(call digit_inc,$3),$4))
rl_plus2 = $(call rl_plus3,$1,$2,$3,$4,$5,$6,$(call digit_add,$3,$4))
rl_plus = $(__gmsl_tr2)$(call rl_asx,rl_plus2,$1,$2)

# ----------------------------------------------------------------------------
# Function:  rl_subtract
# Arguments: 1: An unsigned integer in reversed list form
#            2: An unsigned integer in reversed list form
# Returns:   Argument 2 subtaracted from argument 1, undefined if argument 2 is
#            larger than argument 1
# ----------------------------------------------------------------------------
rl_subtractc4 = $(if $2,$(call rl_asx,rl_subtractc2,$1,$2),$(call rl_dec,$1))
rl_subtract4 = $(if $2,$(call rl_subtract,$1,$2),$1)
rl_subtractc3 = $7 $(if $(call nlz_eq,$3,0)$(call digit_lt,$3,$7),$(call rl_subtractc4,$5,$6),$(call rl_subtract4,$5,$6))
rl_subtract3 = $7 $(if $(call digit_lt,$3,$7),$(call rl_subtractc4,$5,$6),$(call rl_subtract4,$5,$6))
rl_subtractc2 = $(call rl_subtractc3,$1,$2,$3,$4,$5,$6,$(call digit_sub,$(call digit_dec,$3),$4))
rl_subtract2 = $(call rl_subtract3,$1,$2,$3,$4,$5,$6,$(call digit_sub,$3,$4))
rl_subtract = $(__gmsl_tr2)$(call rl_slzs,$(call rl_asx,rl_subtract2,$1,$2))

# ----------------------------------------------------------------------------
# Function:  rl_multiply
# Arguments: 1: An unsigned integer in reversed list form
#            2: An unsigned integer in reversed list form
# Returns:   Argument 1 multiplied by argument 2
# ----------------------------------------------------------------------------
rl_multiply_nai3 = $(call rl_multiply_nai2,$(call rl_plus,$1,$3),$(call rl_dec,$2),$3)
rl_multiply_nai2 = $(if $(call nlz_eq,$(words $2),1),$(if $(call nlz_eq,$2,0),0,$(if $(call nlz_eq,$2,1),$1,$(call rl_multiply_nai3,$1,$2,$3))),$(call rl_multiply_nai3,$1,$2,$3))
rl_multiply_nai = $(call rl_multiply_nai2,$1,$2,$1)

rl_multiply = $(__gmsl_tr2)$(strip $(if $(call nlz_eq,$(words $2),1),\
	$3 $(call rl_multiply_nai,$1,$(firstword $2)),\
	$(call rl_plus,$3 $(call rl_multiply_nai,$1,$(firstword $2)),$(call rl_multiply,$1,$(wordlist 2,$(words $2),$2),$3 0))))

# ----------------------------------------------------------------------------
# Function:  rl_divide
# Arguments: 1: An unsigned integer in reversed list form
#            2: An unsigned integer in reversed list form
# Returns:   Argument 1 divided by argument 2, undefined if argument 2 is 0
# ----------------------------------------------------------------------------
rl_divide_nai2 = $(if $(call rl_lt,$1,$2),$5r$(call rl_subtract,$1,$4),$(call rl_divide_nai2,$1,$(call rl_plus,$2,$3),$3,$2,$(call rl_inc,$5)))
rl_divide_nai = $(call rl_divide_nai2,$1,$2,$2,0,0)

rl_divide5 = $(if $(call nlz_eq,$3,0),$5 $4,$(call rl_divide2,$7,$2,$3,$5 $4))
rl_divide4 = $(call rl_divide5,$1,$2,$3,$4,$5,$6,$(wordlist 1,$3,$1) $(if $(call nlz_eq,$(words $6),1),$(if $(call nlz_eq,$6,0),,$6),$6))
rl_divide3 = $(call rl_divide4,$1,$2,$(call us_dec,$3),$4,$(call arith_split,$(firstword $5)),$(call arith_split,$(lastword $5)))
rl_divide2 = $(call rl_divide3,$1,$2,$3,$4,$(call subst,r,$(__gmsl_space),$(call arith_concat,$(call rl_divide_nai,$(wordlist $3,$(words $1),$1),$2))))
rl_divide = $(__gmsl_tr2)$(call rl_slzs,$(call rl_divide2,$1,$2,$(words $1)))

# ----------------------------------------------------------------------------
# Function:  rl_power
# Arguments: 1: An unsigned integer in reversed list form
#            2: An unsigned integer in reversed list form
# Returns:   Argument 1 to the power of argument 2
# ----------------------------------------------------------------------------
rl_power3 = $(call rl_power2,$(call rl_multiply,$1,$3),$(call rl_dec,$2),$3)
rl_power2 = $(if $(call nlz_eq,$(words $2),1),$(if $(call nlz_eq,$2,0),$1,$(call rl_power3,$1,$2,$3)),$(call rl_power3,$1,$2,$3))
rl_power = $(__gmsl_tr2)$(call rl_power2,1,$2,$1)

# ----------------------------------------------------------------------------
# Function:  rl_gpower
# Arguments: 1: An unsigned integer in reversed list form
#            2: An unsigned integer in reversed list form
# Returns:   The largest power of argument 2 below or equal to argument 1
# ----------------------------------------------------------------------------
rl_gpower3 = $(if $(call rl_lt,$1,$4),$2,$(call rl_gpower2,$1,$4,$3))
rl_gpower2 = $(call rl_gpower3,$1,$2,$3,$(call rl_multiply,$2,$3))
rl_gpower = $(call rl_gpower2,$1,1,$2)

# functions for dealing with unsigned numbers

# ----------------------------------------------------------------------------
# Function:  us_slzs
# Arguments: 1: An unsigned integer in human readable decimal form
# Returns:   The argument stripped of its leading zeros
# ----------------------------------------------------------------------------
us_slzs = $(if $(call nlz_eq,$1,0),0,$(if $(1:0%=),$1,$(call us_slzs,$(1:0%=%))))

# ----------------------------------------------------------------------------
# Function:  us_eq
# Arguments: 1: An unsigned integer in human readable decimal form
#            2: An unsigned integer in human readable decimal form
# Returns:   A non empty string if the 2 arguments are equal, otherwise an empty
#            string
# ----------------------------------------------------------------------------
us_eq = $(__gmsl_tr2)$(call nlz_eq,$(call us_slzs,$1),$(call us_slzs,$2))

# ----------------------------------------------------------------------------
# Function:  us_lt
# Arguments: 1: An unsigned integer in human readable decimal form
#            2: An unsigned integer in human readable decimal form
# Returns:   A non empty string if argument 1 is less than argument 2, otherwise an empty
#            string
# ----------------------------------------------------------------------------
us_lt = $(__gmsl_tr2)$(call l_wrap2,l_lt,$1,$2)

# ----------------------------------------------------------------------------
# Function:  us_inc
# Arguments: 1: An unsigned integer in human readable decimal form
# Returns:   The argument incremented by one
# ----------------------------------------------------------------------------
us_inc = $(__gmsl_tr1)$(call rl_wrap,rl_inc,$1)

# ----------------------------------------------------------------------------
# Function:  us_dec
# Arguments: 1: An unsigned integer in human readable decimal form
# Returns:   The argument decremented by one
# ----------------------------------------------------------------------------
us_dec = $(__gmsl_tr1)$(call rl_wrap,rl_dec,$1)

# ----------------------------------------------------------------------------
# Function:  us_plus
# Arguments: 1: An unsigned integer in human readable decimal form
#            2: An unsigned integer in human readable decimal form
# Returns:   The sum of argument 1 and argument 2
# ----------------------------------------------------------------------------
us_plus = $(__gmsl_tr2)$(call rl_wrap2,rl_plus,$1,$2)

# ----------------------------------------------------------------------------
# Function:  us_subtract
# Arguments: 1: An unsigned integer in human readable decimal form
#            2: An unsigned integer in human readable decimal form
# Returns:   Argument 2 subtracted from argument 1
# ----------------------------------------------------------------------------
us_subtract = $(__gmsl_tr2)$(call rl_wrap2,rl_subtract,$1,$2)

# ----------------------------------------------------------------------------
# Function:  us_multiply
# Arguments: 1: An unsigned integer in human readable decimal form
#            2: An unsigned integer in human readable decimal form
# Returns:   Argument 1 multiplied by argument 2
# ----------------------------------------------------------------------------
us_multiply = $(__gmsl_tr2)$(call rl_wrap2,rl_multiply,$1,$2)

# ----------------------------------------------------------------------------
# Function:  us_divide
# Arguments: 1: An unsigned integer in human readable decimal form
#            2: An unsigned integer in human readable decimal form
# Returns:   Argument 1 divided by argument 2
# ----------------------------------------------------------------------------
us_divide = $(__gmsl_tr2)$(if $(call eq,$2,0),Division by zero,$(call rl_wrap2,rl_divide,$1,$2))

# ----------------------------------------------------------------------------
# Function:  us_power
# Arguments: 1: An unsigned integer in human readable decimal form
#            2: An unsigned integer in human readable decimal form
# Returns:   Argument 1 to the power of argument 2
# ----------------------------------------------------------------------------
us_power = $(__gmsl_tr2)$(call rl_wrap2,rl_power,$1,$2)

# ----------------------------------------------------------------------------
# Function:  us_gpower
# Arguments: 1: An unsigned integer in human readable decimal form
#            2: An unsigned integer in human readable decimal form
# Returns:   The largest power of argument 2 below or equal to argument 1
# ----------------------------------------------------------------------------
us_gpower = $(__gmsl_tr2)$(call rl_wrap2,rl_gpower,$1,$2)

# ----------------------------------------------------------------------------
# Function:  us_dec2basen
# Arguments: 1: An unsigned integer in human readable decimal form
#            2: An unsigned integer in human readable decimal form
# Returns:   Argument 1 represented in base argument 2, undefined if argument 2
# is over 16
# ----------------------------------------------------------------------------
us_dec2basen3 = $(call us_dec2basen2,$(call us_subtract,$1,$(call us_multiply,$3,$5)),$2,$(call us_divide,$3,$2),$4$(word $(call us_inc,$5),$(__gmsl_hex_digits)))
us_dec2basen2 = $(if $(call us_eq,$3,0),$(if $4,$4,0),$(call us_dec2basen3,$1,$2,$3,$4,$(call us_divide,$1,$3)))
us_dec2basen = $(call us_dec2basen2,$1,$2,$(call us_gpower,$1,$2))

# ----------------------------------------------------------------------------
# Function:  us_dec2hex, us_dec2bin, us_dec2oct
# Arguments: 1: An unsigned integer
# Returns:   The decimal argument converted to hexadecimal, binary or
#            octal
# ----------------------------------------------------------------------------
us_dec2hex = $(__gmsl_tr1)$(call us_dec2basen,$1,16)
us_dec2bin = $(__gmsl_tr1)$(call us_dec2basen,$1,2)
us_dec2oct = $(__gmsl_tr1)$(call us_dec2basen,$1,8)

# functions for dealing with signed numbers

# ----------------------------------------------------------------------------
# Function:  neg
# Arguments: 1: A signed integer
# Returns:   A non empty string if the arguemnt is negative, otherwise an empty
#            string
# ----------------------------------------------------------------------------
neg = $(__gmsl_tr1)$(filter -%,$1)

# ----------------------------------------------------------------------------
# Function:  abs
# Arguments: 1: A signed integer
# Returns:   The absolute value of the argument
# ----------------------------------------------------------------------------
abs = $(1:-%=%)

# ----------------------------------------------------------------------------
# Function:  eq
# Arguments: 1: A signed decimal integer
#            2: A signed decimal integer
# Returns:   $(true) if the 2 arguments are equal, otherwise $(false)
# ----------------------------------------------------------------------------
eq = $(__gmsl_tr2)$(if $(call neg,$1),$(if $(call neg,$2),$(call us_eq,$(call abs,$1),$(call abs,$2)),$(false)),$(if $(call neg,$2),$(false),$(call us_eq,$1,$2)))

# ----------------------------------------------------------------------------
# Function:  lt
# Arguments: 1: A signed decimal integer
#            2: A signed decimal integer
# Returns:   $(true) if argument 1 is less than argument 2, otherwise $(false)
# ----------------------------------------------------------------------------
lt = $(__gmsl_tr2)$(strip $(if $(call neg,$1),\
	$(if $(call neg,$2),\
		$(call us_lt,$(call abs,$2),$(call abs,$1)),\
		$(true)),\
	$(if $(call neg,$2),$(false),\
		$(call us_lt,$1,$2))))

# ----------------------------------------------------------------------------
# Function:  gt
# Arguments: 1: A signed decimal integer
#            2: A signed decimal integer
# Returns:   $(true) if argument 1 is greater than argument 2, otherwise
# 	     $(false)
# ----------------------------------------------------------------------------
gt = $(__gmsl_tr2)$(call lt,$2,$1)

# ----------------------------------------------------------------------------
# Function:  ne
# Arguments: 1: A signed decimal integer
#            2: A signed decimal integer
# Returns:   True if the 2 arguments are not equal, otherwise false
# ----------------------------------------------------------------------------
ne = $(__gmsl_tr2)$(call not,$(call eq,$1,$2))

# ----------------------------------------------------------------------------
# Function:  lte
# Arguments: 1: A signed decimal integer
#            2: A signed decimal integer
# Returns:   $(true) if argument 1 is less than or equal to argument 2,
# 	     otherwise $(false)
# ----------------------------------------------------------------------------
lte = $(__gmsl_tr2)$(call not,$(call gt,$1,$2))

# ----------------------------------------------------------------------------
# Function:  lte
# Arguments: 1: A signed decimal integer
#            2: A signed decimal integer
# Returns:   $(true) if argument 1 is greater than or equal to argument 2,
# 	     otherwise $(false)
# ----------------------------------------------------------------------------
gte = $(__gmsl_tr2)$(call not,$(call lt,$1,$2))

# ----------------------------------------------------------------------------
# Function:  min, max
# Arguments: 1: A signed decimal integer
#            2: A signed decimal integer
# Returns:   The smaller (min) or larger (max) of the arguments
# ----------------------------------------------------------------------------
min = $(__gmsl_tr2)$(if $(call lt,$1,$2),$1,$2)
max = $(__gmsl_tr2)$(if $(call lt,$1,$2),$2,$1)

# ----------------------------------------------------------------------------
# Function:  inc, dec
# Arguments: 1: A signed decimal integer
# Returns:   The argument incremented or decremented by one
# ----------------------------------------------------------------------------
inc = $(__gmsl_tr1)$(if $(call neg,$1),$(if $(call is_eq,$1,-1),0,-$(call us_dec,$(call abs,$1))),$(call us_inc,$1))
dec = $(__gmsl_tr1)$(if $(call neg,$1),-$(call us_inc,$(call abs,$1)),$(if $(call is_eq,$1,0),-1,$(call us_dec,$1)))

# ----------------------------------------------------------------------------
# Function:  plus
# Arguments: 1: A signed decimal integer
#            2: A signed decimal integer
# Returns:   The sum of argument 1 and argument 2
# ----------------------------------------------------------------------------
plus = $(__gmsl_tr2)$(strip $(if $(call neg,$1),\
	$(if $(call neg,$2),\
		-$(call us_plus,$(call abs,$1),$(call abs,$2)),\
		$(if $(call us_lt,$2,$(call abs,$1)),\
			-$(call us_subtract,$(call abs,$1),$2),\
			$(call us_subtract,$2,$(call abs,$1)))),\
	$(if $(call neg,$2),\
		$(if $(call us_lt,$1,$(call abs,$2)),\
			-$(call us_subtract,$(call abs,$2),$1),\
			$(call us_subtract,$1,$(call abs,$2))),\
		$(call us_plus,$1,$2))))

# ----------------------------------------------------------------------------
# Function:  subtract
# Arguments: 1: A signed decimal integer
#            2: A signed decimal integer
# Returns:   Argument 2 subtracted from argument 1
# ----------------------------------------------------------------------------
subtract = $(__gmsl_tr2)$(strip $(if $(call neg,$1),\
	$(if $(call neg,$2),\
		$(if $(call us_lt,$(call abs,$2),$(call abs,$1)),\
			-$(call us_subtract,$(call abs,$1),$(call abs,$2)),\
			$(call us_subtract,$(call abs,$2),$(call abs,$1))),\
		-$(call us_plus,$2,$(call abs,$1))),\
	$(if $(call neg,$2),\
		$(call us_plus,$1,$(call abs,$2)),\
		$(if $(call us_lt,$1,$2),\
			-$(call us_subtract,$2,$1),\
			$(call us_subtract,$1,$2)))))

__mds = $(strip $(patsubst -0,0,$(if $(call neg,$2),\
	$(if $(call neg,$3),$(call $1,$(call abs,$2),$(call abs,$3)),-$(call $1,$(call abs,$2),$3)),\
	$(if $(call neg,$3),-$(call $1,$2,$(call abs,$3)),$(call $1,$2,$3)))))

# ----------------------------------------------------------------------------
# Function:  multiply
# Arguments: 1: A signed decimal integer
#            2: A signed decimal integer
# Returns:   Argument 1 multiplied by argument 2
# ----------------------------------------------------------------------------
multiply = $(__gmsl_tr2)$(call __mds,us_multiply,$1,$2)

# ----------------------------------------------------------------------------
# Function:  divide
# Arguments: 1: A signed decimal integer
#            2: A signed decimal integer
# Returns:   Argument 1 divided by argument 2
# ----------------------------------------------------------------------------
divide = $(__gmsl_tr2)$(call __mds,us_divide,$1,$2)

# ----------------------------------------------------------------------------
# Function:  power
# Arguments: 1: A signed decimal integer
#            2: A signed decimal integer
# Returns:   Argument 1 to the power of argument 2
# ----------------------------------------------------------------------------
power = $(__gmsl_tr2)$(if $(call neg,$2),0,$(call us_power,$(call abs,$1),$2))

# ----------------------------------------------------------------------------
# Function:  sequence
# Arguments: 1: An integer
#            2: An integer
# Returns:   The incrementing sequence [arg1, ..., arg2] of integers.
#            If arg1 == arg2 return [arg1]
# ----------------------------------------------------------------------------
sequence = $(__gmsl_tr2)$(if $(call eq,$1,$2),$1,$1 $(call sequence,$(if $(call lt,$1,$2),$(call inc,$1),$(call dec,$1)),$2))

# ----------------------------------------------------------------------------
# Function:  dec2hex, dec2bin, dec2oct
# Arguments: 1: An integer
# Returns:   The decimal argument converted to hexadecimal, binary or
#            octal
# ----------------------------------------------------------------------------

dec2hex = $(__gmsl_tr1)$(if $(call neg,$1),-,)$(call us_dec2hex,$(call abs,$1))
dec2bin = $(__gmsl_tr1)$(if $(call neg,$1),-,)$(call us_dec2bin,$(call abs,$1))
dec2oct = $(__gmsl_tr1)$(if $(call neg,$1),-,)$(call us_dec2oct,$(call abs,$1))

# functions for backwards compatibility

int_encode = $(call rl_encode,$1)
int_decode = $(call rl_decode,$1)
int_inc = $(strip $(call rl_inc,$1))
int_dec = $(strip $(call rl_dec,$1))
int_plus = $(strip $(call rl_plus,$1,$2))
int_subtract = $(strip $(if $(call rl_lt,$1,$2),Subtraction underflow,$(call rl_subtract,$1,$2)))
int_multiply = $(call rl_multiply,$1,$2)
int_divide = $(strip $(if $(call eq,$2,0),Division by zero,$(call rl_divide,$1,$2)))
int_max = $(if $(call rl_lt,$1,$2),$2,$1)
int_min = $(if $(call rl_lt,$1,$2),$1,$2)
int_double = $(call rl_multiply,$1,2)
double = $(call multiply,$1,2)
int_halve = $(strip $(call rl_divide,$1,2))
halve = $(call divide,$1,2)
int_gt = $(call rl_lt,$2,$1)
int_gte = $(call not,$(call rl_lt,$1,$2))
int_lt = $(call rl_lt,$1,$2)
int_lte = $(call not,$(call int_lt,$2,$1))
int_eq = $(call eq,$(call rl_decode,$1),$(call rl_decode,$2))
int_ne = $(call not,$(call int_eq,$1,$2))
__strip_leading_zero = $(call us_slzs,$(if $1,$1,0))

ifdef __gmsl_have_eval
# ###########################################################################
# ASSOCIATIVE ARRAYS
# ###########################################################################

# Magic string that is very unlikely to appear in a key or value

__gmsl_aa_magic := faf192c8efbc25c27992c5bc5add390393d583c6

# ----------------------------------------------------------------------------
# Function:  set
# Arguments: 1: Name of associative array
#            2: The key value to associate
#            3: The value associated with the key
# Returns:   Nothing
# ----------------------------------------------------------------------------
set = $(__gmsl_tr3)$(call assert_no_space,$0,$1$2)$(call assert_no_dollar,$0,$1$2$3)$(eval __gmsl_aa_$1_$(__gmsl_aa_magic)_$2_gmsl_aa_$1 := $3)

# Only used internally by memoize function

__gmsl_set = $(call set,$1,$2,$3)$3

# ----------------------------------------------------------------------------
# Function:  get
# Arguments: 1: Name of associative array
#            2: The key to retrieve
# Returns:   The value stored in the array for that key
# ----------------------------------------------------------------------------
get = $(strip $(__gmsl_tr2)$(call assert_no_space,$0,$1$2)$(call assert_no_dollar,$0,$1$2)$(__gmsl_aa_$1_$(__gmsl_aa_magic)_$2_gmsl_aa_$1))

# ----------------------------------------------------------------------------
# Function:  keys
# Arguments: 1: Name of associative array
# Returns:   Returns a list of all defined keys in the array
# ----------------------------------------------------------------------------
keys = $(__gmsl_tr1)$(call assert_no_space,$0,$1)$(call assert_no_dollar,$0,$1)$(sort $(patsubst __gmsl_aa_$1_$(__gmsl_aa_magic)_%_gmsl_aa_$1,%, \
                  $(filter __gmsl_aa_$1_$(__gmsl_aa_magic)_%_gmsl_aa_$1,$(.VARIABLES))))

# ----------------------------------------------------------------------------
# Function:  defined
# Arguments: 1: Name of associative array
#            2: The key to test
# Returns:   Returns true if the key is defined (i.e. not empty)
# ----------------------------------------------------------------------------
defined = $(__gmsl_tr2)$(call assert_no_space,$0,$1$2)$(call assert_no_dollar,$0,$1$2)$(call sne,$(call get,$1,$2),)

endif # __gmsl_have_eval

ifdef __gmsl_have_eval
# ###########################################################################
# NAMED STACKS
# ###########################################################################

# ----------------------------------------------------------------------------
# Function:  push
# Arguments: 1: Name of stack
#            2: Value to push onto the top of the stack (must not contain
#               a space)
# Returns:   None
# ----------------------------------------------------------------------------
push = $(__gmsl_tr2)$(call assert_no_space,$0,$1$2)$(call assert_no_dollar,$0,$1$2)$(eval __gmsl_stack_$1 := $2 $(if $(filter-out undefined,\
    $(origin __gmsl_stack_$1)),$(__gmsl_stack_$1)))

# ----------------------------------------------------------------------------
# Function:  pop
# Arguments: 1: Name of stack
# Returns:   Top element from the stack after removing it
# ----------------------------------------------------------------------------
pop = $(__gmsl_tr1)$(call assert_no_space,$0,$1)$(call assert_no_dollar,$0,$1)$(strip $(if $(filter-out undefined,$(origin __gmsl_stack_$1)), \
    $(call first,$(__gmsl_stack_$1))                                       \
    $(eval __gmsl_stack_$1 := $(call rest,$(__gmsl_stack_$1)))))

# ----------------------------------------------------------------------------
# Function:  peek
# Arguments: 1: Name of stack
# Returns:   Top element from the stack without removing it
# ----------------------------------------------------------------------------
peek = $(__gmsl_tr1)$(call assert_no_space,$0,$1)$(call assert_no_dollar,$0,$1)$(call first,$(__gmsl_stack_$1))

# ----------------------------------------------------------------------------
# Function:  depth
# Arguments: 1: Name of stack
# Returns:   Number of items on the stack
# ----------------------------------------------------------------------------
depth = $(__gmsl_tr1)$(call assert_no_space,$0,$1)$(call assert_no_dollar,$0,$1)$(words $(__gmsl_stack_$1))

endif # __gmsl_have_eval

ifdef __gmsl_have_eval
# ###########################################################################
# STRING CACHE
# ###########################################################################

# ----------------------------------------------------------------------------
# Function:  memoize
# Arguments: 1. Name of the function to be called if the string
#               has not been previously seen
#            2. A string
# Returns:   Returns the result of a memo function (which the user must
#            define) on the passed in string and remembers the result.
#
# Example:   Set memo = $(shell echo "$1" | md5sum) to make a cache
#            of MD5 hashes of strings. $(call memoize,memo,foo bar baz)
# ----------------------------------------------------------------------------
__gmsl_memoize = $(subst $(__gmsl_space),�,$1)cc2af1bb7c4482f2ba75e338b963d3e7$(subst $(__gmsl_space),�,$2)
memoize = $(__gmsl_tr2)$(strip $(if $(call defined,__gmsl_m,$(__gmsl_memoize)),\
                  $(call get,__gmsl_m,$(__gmsl_memoize)),                      \
                  $(call __gmsl_set,__gmsl_m,$(__gmsl_memoize),$(call $1,$2))))

endif # __gmsl_have_eval

# ###########################################################################
# DEBUGGING FACILITIES
# ###########################################################################

# ----------------------------------------------------------------------------
# Target:    gmsl-print-%
# Arguments: The % should be replaced by the name of a variable that you
#            wish to print out.
# Action:    Echos the name of the variable that matches the % and its value.
#            For example, 'make gmsl-print-SHELL' will output the value of
#            the SHELL variable
# ----------------------------------------------------------------------------
gmsl-print-%: ; @echo $* = $($*)

# ----------------------------------------------------------------------------
# Function:  assert
# Arguments: 1: A boolean that must be true or the assertion will fail
#            2: The message to print with the assertion
# Returns:   None
# ----------------------------------------------------------------------------
assert = $(if $2,$(if $1,,$(call __gmsl_error,Assertion failure: $2)))

# ----------------------------------------------------------------------------
# Function:  assert_exists
# Arguments: 1: Name of file that must exist, if it is missing an assertion
#               will be generated
# Returns:   None
# ----------------------------------------------------------------------------
assert_exists = $(if $0,$(call assert,$(wildcard $1),file '$1' missing))

# ----------------------------------------------------------------------------
# Function:  assert_no_dollar
# Arguments: 1: Name of a function being executd
#            2: Arguments to check
# Returns:   None
# ----------------------------------------------------------------------------
assert_no_dollar = $(call __gmsl_tr2)$(call assert,$(call not,$(findstring $(__gmsl_dollar),$2)),$1 called with a dollar sign in argument)

# ----------------------------------------------------------------------------
# Function:  assert_no_space
# Arguments: 1: Name of a function being executd
#            2: Arguments to check
# Returns:   None
# ----------------------------------------------------------------------------
ifeq ($(__gmsl_spaced_vars),$(false))
assert_no_space = $(call assert,$(call not,$(findstring $(__gmsl_aa_magic),$(subst $(__gmsl_space),$(__gmsl_aa_magic),$2))),$1 called with a space in argument)
else
assert_no_space =
endif
